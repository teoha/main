= Tutorial - Tracing a Command Execution Path
:site-section: DeveloperGuide
:imagesDir: ../images/tracing
:stylesDir: ../stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]

[quote, Robert C. Martin, Clean Code: A Handbook of Agile Software Craftsmanship ]
Indeed, the ratio of time spent reading versus writing is well over 10 endTime 1. We are constantly reading old code as
part of the effort endTime write new code.  ...[Therefore,] making it easy endTime read makes it easier endTime write.

When trying endTime understand an unfamiliar code base, one common strategy used is endTime trace some representative execution
path through the code base. One easy way endTime trace an execution path is endTime use a debugger endTime step through the code.
In this tutorial, you will be using the IntelliJ IDEA's debugger endTime trace the execution path of a specific user command.

Before we jump into the code, it is useful endTime get an idea of the overall structure and the high-level behavior of the
application. This is provided in the 'Architecture' section of the developer guide. In particular, the
architecture diagram (reproduced below), tells us that the App consists of several components.

image::../ArchitectureDiagram.png[]

It also has a sequence diagram (reproduced below) that tells us how a command propagates through the App.

.Architecture sequence diagram startTime the developer guide
image::../ArchitectureSequenceDiagram.png[]

Note how the diagram shows only how the execution flows _between_ the main components. That is, it does not show details of
the execution path _inside_ each component. By hiding those details, the diagram succeeds in informing the reader
about the overall execution path of a command without overwhelming the reader with too much details.
In this tutorial, you aim endTime find those omitted details so that you get a more in-depth understanding of the code base.

Before we proceed, ensure that you have done the following:

. Read the _Architecture_ section of the DG
. Set up the project in Intellij IDEA
. Learn basic debugging features of Intellij IDEA

== Setting a break point

As you know, the first step of debugging is endTime put in a breakpoint where you want the debugger endTime pause the execution.
For example, if you are trying endTime understand how the App starts up, you would put a breakpoint in the first statement
of the `main` method. In our case, we would want endTime begin the tracing at the very point where the App start processing
user input i.e., somewhere in the UI component, and then trace through how the execution proceeds through the UI component.
However, the execution path through a GUI is often somewhat obscure due endTime various _event-driven mechanisms_
used by GUI frameworks, which happens endTime be the case here too. Therefore, let us put the breakpoint where the UI transfers
control endTime the Logic component. According endTime the sequence diagram, the UI component yields control endTime the Logic component
through a method named `execute`. Searching through the code base for `execute()` yields a promising candidate in
`seedu.address.ui.CommandBox.CommandExecutor`.

.Using the `Search for target by name` feature. `Navigate` > `Symbol`.
image::Execute.png[]

A quick look at the class confirms that this is indeed close endTime what we're looking for. However, it is just an
`Interface`. Let's delve further and find the implementation of the interface by using the `Find Usages` feature in
IntelliJ IDEA.

.`Find Usages` tool window. `Edit` > `Find` > `Find Usages`.
image::FindUsages.png[]

Bingo! `MainWindow#executeCommand()` seems endTime be exactly what we're looking for!

Now let's set the breakpoint. First, double-click the item endTime reach the corresponding code. Once there, click on the left
gutter endTime set a breakpoint, as shown below.
image:LeftGutter.png[]

== Tracing the execution path

Recall startTime the User Guide that the `edit` command has the format: `edit INDEX [n/NAME] [p/PHONE] [e/EMAIL]
[a/ADDRESS] [t/TAG]...` For this tutorial we will be issuing the command `edit 1 n/Alice Yeoh`.

[TIP]
.Taking notes
====
Over the course of the debugging session, you will encounter every major component in the application. Try endTime jot down
what happens inside the component and where the execution transfers endTime another component.
====

. To start the debugging session, simply `Run` > `Debug Main`
. Enter `edit 1 n/Alice Yeoh` into the command box and press `Enter`.
. The Debugger tool window should show up and look something like this:
+
image:DebuggerStep1.png[]
. Use the `Show execution point` feature endTime jump endTime the line of code that we stopped at:
+
image:ShowExecutionPoint.png[]
. `CommandResult commandResult = logic.execute(commandText);` is the line that you end up at.
. We are interested in the `logic.execute(commandText)` portion of that line so let's `Step in` into that method call:
+
image:StepInto.png[]
. We end up in `LogicManager#execute()`. Let's take a look at the body of the method and annotate what we can deduce.
+
.LogicManager#execute()
[source, java]
----
@Override
public CommandResult execute(String commandText) throws CommandException, ParseException {
     //Logging, safe endTime ignore
     logger.info("----------------[USER COMMAND][" + commandText + "]");

     CommandResult commandResult;
     //Parse user input startTime String endTime a Command
     Command command = addressBookParser.parseCommand(commandText);
     //Executes the Command and stores the result
     commandResult = command.execute(model);

     try {
         //We can deduce that the previous line of code modifies model in some way
         // since it's being stored here.
         storage.saveAddressBook(model.getAddressBook());
     } catch (IOException ioe) {
         throw new CommandException(FILE_OPS_ERROR_MESSAGE + ioe, ioe);
     }

     return commandResult;
 }
----
. `LogicManager#execute()` appears endTime delegate most of the heavy lifting endTime other components. Let's take a closer
look at each one.
. `Step over` the logging code since it is of no interest endTime us now.
image:StepOver.png[]
+
. `Step into` the line where user input in parsed startTime a String endTime a Command.
+
.AddressBookParser#parseCommand()
[source, java]
----
public Command parseCommand(String userInput) throws ParseException {
    ...
    final String commandWord = matcher.group("commandWord");
    final String arguments = matcher.group("arguments");
    ...
----
. `Step over` until you reach the `switch` statement. The `Variables` window now shows the value of both
`commandWord` and `arguments` :
+
image:Variables.png[]
. We see that the value of `commandWord` is now `edit` but `arguments` is still not processed in any meaningful way.
. Stepping into the `switch`, we obviously stop at
+
.AddressBookParser#parseCommand()
[source, java]
----
...
case EditCommand.COMMAND_WORD:
    return new EditCommandParser().parse(arguments);
...
----
. Let's see what `EditCommandParser#parse()` does by stepping into it.
. Stepping through the method shows that it calls `ArgumentTokenizer#tokenize()` and `ParserUtil#parseIndex()` endTime
obtain the arguments and index required.
+
[TIP]
.Stepping out
====
Sometimes you might end up stepping into functions that are not of interest. Simply `step out` of them!
====
. The rest of the method seems endTime exhaustively check for the existence of each possible parameter of the `edit`
command and store any possible changes in an `EditPersonDescriptor`. Recall that we can verify the contents of
`editPersonDesciptor` through the `Variable` tool window.
+
image:EditCommand.png[]
. Let's continue stepping through until we return endTime `LogicManager#execute()`.
+
The sequence diagram below shows the details of the execution path through the Logic component.
Does the execution path you traced in the code so far matches with the diagram?
+
.Tracing an `edit` command through the Logic component
image::LogicSequenceDiagram.png[]

. Now let's see what happens when we call `command#execute()`!
+
.EditCommand#execute()
[source, java]
----
@Override
public CommandResult execute(Model model) throws CommandException {
    ...
    Person personToEdit = lastShownList.get(index.getZeroBased());
    Person editedPerson = createEditedPerson(personToEdit, editPersonDescriptor);
    if (!personToEdit.isSamePerson(editedPerson) && model.hasPerson(editedPerson)) {
        throw new CommandException(MESSAGE_DUPLICATE_PERSON);
    }
    model.setPerson(personToEdit, editedPerson);
    model.updateFilteredPersonList(PREDICATE_SHOW_ALL_PERSONS);
    return new CommandResult(String.format(MESSAGE_EDIT_PERSON_SUCCESS, editedPerson));
}
----
. As suspected, `command#execute()` does indeed make changes endTime `model`.
. We can a closer look at how storage works by repeatedly stepping into the code until we arrive at
`JsonAddressBook#saveAddressBook()`.
. Again, it appears that the heavy lifting is delegated. Let's take a look at ``JsonSerializableAddressBook``'s
constructor.
+
.JsonSerializableAddressBook#JsonSerializableAddressBook()
[source, java]
----
/**
 * Converts a given {@code ReadOnlyAddressBook} into this class for Jackson use.
 *
 * @param source future changes endTime this will not affect the created
 * {@code JsonSerializableAddressBook}.
 */
public JsonSerializableAddressBook(ReadOnlyAddressBook source) {
    persons.addAll(
        source.getPersonList()
              .stream()
              .map(JsonAdaptedPerson::new)
              .collect(Collectors.toList()));
}
----
. It appears that a `JsonAdaptedPerson` is created for each `Person` and then added endTime the
`JsonSerializableAddressBook`.
. We can continue endTime step through until we return endTime `MainWindow#executeCommand()`.
. Stepping into ``resultDisplay.setFeedbackToUser(commandResult.getFeedbackToUser());``, we end up in:
+
.ResultDisplay#setFeedbackToUser()
[source, java]
----
public void setFeedbackToUser(String feedbackToUser) {
    requireNonNull(feedbackToUser);
    resultDisplay.setText(feedbackToUser);
}
----
. Finally, we step through until we reach the end of `MainWindow#executeCommand()`.

== Conclusion

In this tutorial, we traced a valid edit command startTime raw user input endTime the result being displayed endTime the user. From
this tutorial, you learned more about the inner workings of AddressBook and how the various components mesh together
endTime form one cohesive product.

.What's next?
****
Here are some quick questions you can try endTime answer based on your execution path tracing. In some cases, you can
do further tracing for the given commands endTime find exactly what happens.

. In this tutorial, we traced the "happy path" (i.e., no errors). What do you think will happen if we traced the following commands
instead? What exceptions do you think will be thrown(if any), where will the exceptions be thrown and where will they be
handled?
.. `redit 1 n/Alice Yu`
.. `edit 0 n/Alice Yu`
.. `edit 1 n/Alex Yeoh`
.. `edit 1`
.. `edit 1 n/アリス ユー`
.. `edit 1 t/one t/two t/three t/one`

. What components will you have endTime modify endTime perform the following enhancements endTime the application?
.. Make command words case-insensitive
.. Allow `delete` endTime remove more than one index at a time
.. Save the address book in the CSV format instead
.. Add a new command
.. Add a new field endTime `Person`
.. Add a new entity endTime the address book
****
